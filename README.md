# Чтение защищённой прошивки STM32F0x с помощью Pi Pico

Небольшой PoC, который извлекает 32‑битные слова из защищённой флеш STM32F0x через гонку на шине SWD. Суть: не «болтать» с МК, а сразу после сброса выполнить минимальный набор команд SWD — успевает прочитаться одно слово до срабатывания защиты. Для атаки надо уметь управлять и питанием, и линией reset цели, потому что сброс защиты чтения SWD происходит только после полного обесточивания.

В сети есть другие PoC этого эксплойта debug‑режима, но чаще они завязаны на STM32 с MBED SDK и большим стеком зависимостей. Здесь всё сделано на PlatformIO и портировано на Raspberry Pi Pico (RP2040), чтобы собрать «из коробки».

Работает **только** при защите чтения уровня 1 (RDP Level 1): SWD активен, но после первого обращения защита срабатывает. Уровень 2 полностью блокирует SWD, поэтому этот метод не подходит. С другими линейками STM32 может заработать, но не проверялось (буду рад отчётам).

# Подключение

| Raspberry Pi Pico | STM32 (цель) | Назначение |
| ----------------- | ------------ | ---------- |
| GP14 (pad 15)     | SWDIO        | Дата SWD   |
| GP15 (pad 16)     | SWCLK        | Такт SWD   |
| GP17 (pad 19)     | NRST         | Сброс цели |
| GP26 (pad 17)     | VDD (3.3 В)\*| Питание цели / ключ питания |
| GP16 (на плате)   | WS2812 DIN   | Встроенный адресный статус‑светодиод RP2040‑Tiny |
| 3V3 (pad 21)      | 3.3 В        | Питание Pico / цели |
| VSYS (pad 23)     | 5 В от USB   | Вход/выход 5 В |
| GND (pad 22 или J)| GND          | Общая земля |

Примечания по RP2040‑Tiny:
- GP16 занят встроенным NeoPixel (не использовать для проводов к STM32).
- GP14, GP15, GP26, GP17 (reset) выходят на краевые пэды 15/16/17/19.
- Питание 3.3 В берите с пэда 21 (3V3). USB 5 В — на VSYS (пэд 23), его напрямую на STM32 не подавайте.

\* GP26 — вывод, которым Pico должно жёстко обесточивать и включать цель для каждого слова. Если тока Pico не хватает, подключите GP26 к затвору MOSFET/реле и через него рвите основное питание. Без гарантированного power‑cycle атака не сработает.

Обязательно общая земля между Pico и платой STM32. На разъёмах ST‑Link SWD пины называются SWDIO, SWCLK, NRST, GND, VCC.

# Сборка

Установите PlatformIO:

```bash
pip install platformio
```

Или смотрите инструкции под вашу платформу на https://platformio.org/

Собрать прошивку:

```bash
pio run
```

Готовый UF2 будет в `.pio/pico/firmware.uf2`.

Можно пользоваться и плагином PlatformIO для VS Code.

# Использование

Назначение пинов в [include/main.h](include/main.h):

```c
#define TARGET_RESET_Pin 27
#define TARGET_PWR_Pin 26
#define SWDIO_Pin 14
#define SWCLK_Pin 15

#define NEOPIXEL_PIN        16              // адресный LED (WS2812)
#define NEOPIXEL_COUNT      1
#define NEOPIXEL_BRIGHTNESS 40
#define FLASH_SIZE_BYTES   (256u * 1024u)  // fallback под STM32F091CC (256 KB)
#define FLASH_START_ADDR   (0x08000000u)   // базовый адрес флеш
#define FLASH_SIZE_AUTODETECT (1u)         // 1 = попытка прочитать регистр размера
#define FLASH_SIZE_REG_ADDR  (0x1FFFF7CCu) // адрес регистра размера (STM32F0)
#define START_TIMEOUT_MS   (5000u)         // 0 = ждать ввода бесконечно
```

Pico должно полностью отключать питание цели по `TARGET_PWR_Pin`. Если плата — голый STM32 или с минимальной обвязкой, можно подавать 3.3 В прямо с Pico (учтите небольшой допустимый ток). Если сомневаетесь — ставьте реле/мосфет на питание цели.

По умолчанию код сам читает регистр размера флеш (`FLASH_SIZE_REG_ADDR = 0x1FFFF7CC`, для STM32F0 он содержит объём в КБ) и использует его. Если автодетект не нужен/у вас другая линейка — выключите `FLASH_SIZE_AUTODETECT` и задайте `FLASH_SIZE_BYTES`/`FLASH_START_ADDR` вручную.

После подачи питания Pico будет слать по UART строку `Send anything to start...` — значит, готово. Отправьте любой байт и увидите дамп:

```
Send anything to start...
Starting
0x08000000: deadbeef
0x08000004: deadbeef
0x08000008: deadbeef
0x0800000C: deadbeef
0x08000010: deadbeef
0x08000014: deadbeef
0x08000018: deadbeef
```

Чтобы сохранить в файл, используйте скрипт `dump.py`.

# Быстрый порядок действий

1. Соедините пины по таблице выше, объедините земли.
2. Соберите: `pio run` (получите `.pio/pico/firmware.uf2`).
3. Залейте UF2 на Pico (переведя его в BOOTSEL).
4. Подключите Pico к цели и дайте Pico управлять питанием цели через GP26 (обязательно для атаки).
5. Откройте сериал 115200 бод и нажмите любую клавишу — либо дождитесь автостарта через `START_TIMEOUT_MS`.
6. Для сохранения в файл запустите `python dump.py --port /dev/ttyACM0 firmware.bin`.

# Световая индикация (адресный LED)
- Жёлтый — инициализация.
- Синий — идёт дамп; если цель не подключена, в конце останется синим.
- Красный — ошибка чтения.
- Зелёный — дамп завершён без ошибок.

# Отказ от ответственности

Код основан на статье Йоханнеса Обермайера [Shedding too much Light on a Microcontroller's Firmware Protection](https://www.aisec.fraunhofer.de/en/FirmwareProtection.html). Часть его PoC перенесена на Raspberry Pi Pico и PlatformIO, поэтому распространяется под той же лицензией MIT.
